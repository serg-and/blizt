import { type ParseSafe } from './index'

/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface ParseSafeRes {
  success: boolean
  data?: unknown
  reason?: string
}
export class BArray<R> {
  optional(): BArray<R | undefined>
  nullable(): BArray<R | null>
  nullish(): BArray<R | null | undefined>
  required(): BArray<Exclude<R, undefined>>
  nonNullable(): BArray<Exclude<R, null>>
  /**
   * For internal use only!
   * Create BWrapped instance of this value to be used by other methods
   */
  _toWrapped(): BWrapped
  parseSafe(value: unknown): ParseSafe<R>
  /** For internal use only! */
  static _fromWrapped(wrapped: BWrapped): BArray<unknown>
  parse(value: unknown): R
  length(value: number): BArray<R>
  min(value: number): BArray<R>
  max(value: number): BArray<R>
}
export class BBoolean<R> {
  optional(): BBoolean<R | undefined>
  nullable(): BBoolean<R | null>
  nullish(): BBoolean<R | null | undefined>
  required(): BBoolean<Exclude<R, undefined>>
  nonNullable(): BBoolean<Exclude<R, null>>
  /**
   * For internal use only!
   * Create BWrapped instance of this value to be used by other methods
   */
  _toWrapped(): BWrapped
  parseSafe(value: unknown): ParseSafe<R>
  static default(): BBoolean<boolean>
  parse(value: unknown): R
  isTrue(): BBoolean<R>
  isFalse(): BBoolean<R>
}
export class BNull<R> {
  optional(): BNull<R | undefined>
  nullable(): BNull<R | null>
  nullish(): BNull<R | null | undefined>
  required(): BNull<Exclude<R, undefined>>
  nonNullable(): BNull<Exclude<R, null>>
  /**
   * For internal use only!
   * Create BWrapped instance of this value to be used by other methods
   */
  _toWrapped(): BWrapped
  parseSafe(value: unknown): ParseSafe<R>
  static default(): BNull<null>
  parse(value: unknown): R
}
export class BNumber<R> {
  optional(): BNumber<R | undefined>
  nullable(): BNumber<R | null>
  nullish(): BNumber<R | null | undefined>
  required(): BNumber<Exclude<R, undefined>>
  nonNullable(): BNumber<Exclude<R, null>>
  /**
   * For internal use only!
   * Create BWrapped instance of this value to be used by other methods
   */
  _toWrapped(): BWrapped
  parseSafe(value: unknown): ParseSafe<R>
  static default(): BNumber<number>
  parse(value: unknown): R
  min(min: number): BNumber<R>
  max(max: number): BNumber<R>
  positive(): BNumber<R>
  negative(): BNumber<R>
}
export class BObject<R> {
  optional(): BObject<R | undefined>
  nullable(): BObject<R | null>
  nullish(): BObject<R | null | undefined>
  required(): BObject<Exclude<R, undefined>>
  nonNullable(): BObject<Exclude<R, null>>
  /**
   * For internal use only!
   * Create BWrapped instance of this value to be used by other methods
   */
  _toWrapped(): BWrapped
  parseSafe(value: unknown): ParseSafe<R>
  /** For internal use only! */
  static new(schema: Record<string, BWrapped>): BObject<unknown>
  parse(value: unknown): R
  /**
   * Create a new object schema by merging 2 objects.
   * Optional and Nullable parameters of both objects are ignored for new object.
   */
  merge<T>(schema: BObject<T>): BObject<Omit<Exclude<R, null | undefined>, keyof Exclude<T, null | undefined>> & Exclude<T, null | undefined>>
  /**
   * Strict does not allow unknown keys when parsing.
   * When not strict onknown object keys are removed from the value, when strict parsing fails.
   */
  strict(): BObject<R>
  /** Removes strict option. */
  unStrict(): BObject<R>
}
export class BString<R> {
  optional(): BString<R | undefined>
  nullable(): BString<R | null>
  nullish(): BString<R | null | undefined>
  required(): BString<Exclude<R, undefined>>
  nonNullable(): BString<Exclude<R, null>>
  /**
   * For internal use only!
   * Create BWrapped instance of this value to be used by other methods
   */
  _toWrapped(): BWrapped
  parseSafe(value: unknown): ParseSafe<R>
  static default(): BString<string>
  parse(value: unknown): R
  length(value: number): BString
  min(value: number): BString
  max(value: number): BString
}
export class BTuple<R> {
  optional(): BTuple<R | undefined>
  nullable(): BTuple<R | null>
  nullish(): BTuple<R | null | undefined>
  required(): BTuple<Exclude<R, undefined>>
  nonNullable(): BTuple<Exclude<R, null>>
  /**
   * For internal use only!
   * Create BWrapped instance of this value to be used by other methods
   */
  _toWrapped(): BWrapped
  parseSafe(value: unknown): ParseSafe<R>
  /** For internal use only! */
  static _fromWrapped(wrapped: Array<BWrapped>): unknown
  parse(value: unknown): R
  parse2(value: unknown): R
}
export class BUndefined<R> {
  optional(): BUndefined<R | undefined>
  nullable(): BUndefined<R | null>
  nullish(): BUndefined<R | null | undefined>
  required(): BUndefined<Exclude<R, undefined>>
  nonNullable(): BUndefined<Exclude<R, null>>
  /**
   * For internal use only!
   * Create BWrapped instance of this value to be used by other methods
   */
  _toWrapped(): BWrapped
  parseSafe(value: unknown): ParseSafe<R>
  static default(): BUndefined<undefined>
  parse(value: unknown): R
}
export class BUnion<R> {
  optional(): BUnion<R | undefined>
  nullable(): BUnion<R | null>
  nullish(): BUnion<R | null | undefined>
  required(): BUnion<Exclude<R, undefined>>
  nonNullable(): BUnion<Exclude<R, null>>
  /**
   * For internal use only!
   * Create BWrapped instance of this value to be used by other methods
   */
  _toWrapped(): BWrapped
  parseSafe(value: unknown): ParseSafe<R>
  /** For internal use only! */
  static _fromWrapped(wrapped: Array<BWrapped>): unknown
  parse(value: unknown): R
  merge<T>(schema: BUnion<T>): BUnion<R | T>
}
export class BWrapped { }
